---
format: 
  revealjs:
    target: "_blank"
    scrollable: true
    slide-number: c/t
    chalkboard: true
    title-slide-attributes:
      data-background-image: images/background_title.png
      data-background-size: cover  
    theme: template/theme_perso.scss
    logo: template/logo_marbec.png
    footer: "[https://github.com/umr-marbec/tidyverse-training](https://github.com/umr-marbec/tidyverse-training)"
editor: visual
fig-caption: center
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyr)
library(patchwork)
library(knitr)
library(cowplot)
library(colorBlindness)
library(RColorBrewer)
library(kableExtra)
library(readr)
library(ggplot2)
library(purrr)
library(tibble)
library(stringr)
library(forcats)
library(MASS)
library(viridis)
library(ggpubr)
library(raster)
library(sf)
library(rnaturalearth)
```

#  {background-image="images/background_title.png"}

[Formation R]{style="color:#ffffff; font-size: 2em"}

[Collection de packages tidyverse]{style="color:#ffffff; font-size: 1.5em"}

[Laure Velez (laure.velez\@umontpellier.fr)]{style="color:#ffffff; font-size: 1em"} <br/> [Gael Mariani (gael.mariani\@umontpellier.fr)]{style="color:#ffffff; font-size: 1em"} <br/> [Mathieu Depetris (mathieu.depetris\@ird.fr)]{style="color:#ffffff; font-size: 1em"} <br/> [Monique Simier (monique.simier\@ird.fr)]{style="color:#ffffff; font-size: 1em"} <br/> <br/> [05-06 decembre 2022]{style="color:#ffffff; font-size: 1em"} <br/> <br/> <br/> [© RStudio]{style="color:#ffffff; font-size: 0.4em"}

![](images/tidyverse_packages.png){.absolute top="60" right="20" width="35%"}

## Plan de la formation {.smaller}

-   Préambule et introduction

    -   Prérequis et environnement de travail nécessaire à la formation
    -   Objectifs de la formation
    -   Présentation de tidyverse

-   Partie 1 : Importation de données sous R avec readr

-   Partie 2 : Manipulation de données avec dplyr

-   Partie 3 : Nettoyage des données avec tidyr

-   Partie 4 : Extension à la manipulation de données, cas spécifiques

    -   4.1 : Manipuler du texte avec stringr
    -   4.2 : Manipuler des dates avec lubridate

-   Partie 5 : Visualisation graphique avec ggplot2

-   Partie 6 : Cas pratiques sur vos données

Formation fortement inspirée du site de [Joseph Larmarange](https://larmarange.github.io/analyse-R/){target="_blank"}

# Préambule et introduction

-   Prérequis et environnement de travail nécessaire à la formation
-   Objectifs de la formation
-   Présentation de tidyverse

## Prérequis et environnement de travail nécessaire à la formation

-   Avoir des notions de base dans l'utilisation de R
-   Avoir une instance valide de [R](https://cran.r-project.org/){target="_blank"} sur son poste (durant la formation utilisation de la version 4.2.1)
-   Avoir installé correctement les versions des packages dplyr (utilisation de la version 1.0.10), lubridate (utilisation de la version 1.8.0), ggplot2 (utilisation de la version 3.3.6) et stringr (utilisation de la version 1.4.1)

## Bonus non obligatoire

-   Utilisation de l'environnement de développement [Rstudio](https://www.rstudio.com/products/rstudio/download/){target="_blank"} (utilisation de la version 2022.07.1 Build 554 sous Windows)
-   Pour les utilisateurs de Windows installation de [Rtools](https://cran.r-project.org/bin/windows/Rtools/){target="_blank"} (utilisation de la version 4.2)
-   Installation de [Visual Studio Code](https://code.visualstudio.com/#alt-downloads){target="_blank"} (éditeur de code source autonome)
-   Une instance de [Java](https://jdk.java.net/19/){target="_blank"} (idéalement une version JDK = kit de développement + moteur d'exécution des programmes compilés + outils de compilation)

## Objectifs de la formation

::: columns
::: {.column width="60%"}
-   Vous présenter un panel de ce que l'on peut faire avec ces nouvelles méthodes et surtout vous donner les clés pour aller plus loin
-   Un expert n'est pas forcément quelqu'un qui connaît toutes les fonctions de R par cœur, mais qui sait écouter, comprendre et aller chercher les informations dont il a besoin
    -   Pensez à jeter un coup d'œil aux [cheatsheets](https://github.com/rstudio/cheatsheets){target="_blank"}
-   Prendre le temps de discuter et de regarder vos données et/ou problèmes
:::

::: {.column width="40%"}
![](images/loi_pareto.jpg)
:::
:::

## Présentation de Tidyverse {.smaller}

::: columns
::: {.column width="65%"}
-   Tidyverse c'est quoi ?
    -   tidy + universe ou l'univers du «bien rangé» ou du rangement
    -   Collection d'extensions conçues pour travailler ensemble et basées sur une philosophie commune
    -   Le cœur du package inclut 8 packages
        -   [ggplot2](https://ggplot2.tidyverse.org/){target="_blank"} : création de graphiques
        -   [dplyr](https://dplyr.tidyverse.org/){target="_blank"} : manipulation de données au sens large
        -   [tidyr](https://tidyr.tidyverse.org/){target="_blank"} : manipulation de données plus orientées variables
        -   [readr](https://readr.tidyverse.org/){target="_blank"} : import
        -   [purrr](https://purrr.tidyverse.org/){target="_blank"} : fonction de vectorisation (remplacement des boucles classiques)
        -   [tibble](https://tibble.tidyverse.org/){target="_blank"} : «évolution» du data.frame
        -   [stringr](https://stringr.tidyverse.org/){target="_blank"} : manipulation de caractère
        -   [forcats](https://forcats.tidyverse.org/){target="_blank"} : série d'outils pour aider dans la manipulation des facteurs
:::

::: {.column width="35%"}
![](images/hadley_wickham.png){width="55%"} ![](images/tidyverse_packages.png){width="55%"}
:::
:::

## Présentation de Tidyverse

-   Lancement de la librairie

```{r, echo=TRUE, eval=FALSE}
install.packages("tidyverse")
library(tidyverse)
```

-   Cependant je vous déconseille de faire comme ça
    -   En lançant cette commande, on charge dans R tous les packages associés à tidyverse (les 8 packages cités précédemment, mais aussi les dépendances associées)
    -   Avez-vous vraiment besoin de tout cela ?
    -   Potentiel impact sur vos futurs développements (surtout si vous commencez à développer des packages)
    -   L'idée est d'appliquer dès maintenant les bonnes pratiques et surtout de comprendre ce que cela implique de ne pas les suivre (ce qui est aussi votre droit !)

## Avant d'aller plus loin

-   L'utilisation de ces packages permet de faire beaucoup de choses, mais ne rend pas tout le reste obsolète
-   Il y a plusieurs stratégies pour réaliser une action, il faut juste trouver le bon compromis (connaissances, temps de calcul, contexte global de votre projet...)
-   Attention aux règles et conventions de nommages
    -   Règles pour nommer une variable (obligatoire) : ne pas commencer par un chiffre, pas d'espace, que des caractères alpha-numériques (A-z, 0-9) et le tiret du bas (\_), ne pas utiliser de mots réservés (comme par exemple TRUE)
    -   Conventions pour nommer une variable (recommandé) : uniquement des lettres minuscules, séparer les mots des \_ et les noms choisis doivent pouvoir donner l'information du contenu associé

# Partie 1 : Importation de données sous R avec readr

![](images/logo_readr.png)

## La librairie **readr**

-   Des fonctions de base de R sont dédiées à l'import de fichiers textes de type csv (`read.csv`, `read.csv2`) ou tabulés (`read.table`) ou avec des séparateurs quelconques (`read.delim`)
-   La librairie **readr** propose des fonctions similaires sur le principe mais qui diffèrent des fonctions de base sur certains aspects.
-   Ces fonctions de **readr** sont compatibles avec l'esprit **Tidyverse** car elles permettent de générer des *tibbles*

```{r echo=TRUE, eval=FALSE}
# install.packages("readr", dependencies = T)
# install.packages("tibble", dependencies = T)
library(readr)
library(tibble)
```

## Un ***tibble*** ... Cékoiça ???

-   Le *tibble* est une évolution du *data frame* du R de base
-   Ce format est géré par le package du même nom qui fait partie du coeur de tidyverse
-   Les *tibbles* contiennent un attribut *spec* qui précise les spécifications des colonnes (nom et type)
-   Ils s'affichent plus intelligemment que les *data frames* : seules les premières lignes sont affichées, ainsi que quelques informations supplémentaires utiles
-   Ils autorisent des noms de colonnes qui sont invalides pour les *data frames* (espaces, caractères spéciaux, nombres...)
-   Ils affichent un avertissement si on essaie d'accéder à une colonne qui n'existe pas
-   Ils n'ont pas de noms de lignes (*rownames*).

## Pour passer du *tibble* au *dataframe* et vice-versa

-   La plupart des fonctions du tidyverse acceptent des *data frames* en entrée, mais retournent un objet de classe *tibble*
-   On peut convertir un *data frame* en *tibble* avec la fonction `as_tibble`, ou l'inverse avec la fonction `as.data.frame`

## Les principales fonctions de la librairie **readr**

Les fonctions de readr les plus utilisées sont :

-   `read_delim` : la plus générale, pour lire un fichier avec un délimiteur quelconque
-   `read_csv` : fichiers csv au format anglais (point décimal et séparateur virgule)
-   `read_csv2` : fichiers csv au format français (virgule décimale et séparateur point-virgule)
-   `read_xxx_chunked` (où xxx = csv, csv2, delim) : pour lire un fichier en "chunks", c'est à dire en tranches dont on définit la taille en nombre de lignes. Cette fonction permet de lire de très gros fichiers et aussi d'appliquer une fonction (CallBack) sur les données à chaque tranche.

## Importer en ***tibble*** le fichier Global_reef_fish_biomass.csv

-   Ce fichier est au format csv anglais (séparateur décimal = point et séparateur de colonnes = virgule).

-   Chaque ligne donne une valeur de biomasse pour une campagne (survey_id), une espèce de poisson (species_name) et une classe de taille de 0.5cm (size_class).

-   Lecture avec `read_delim` : preciser le delimiteur de colonnes (ici la virgule)

```{r echo=TRUE, eval=FALSE}
global_reef_fish_biomass <- read_delim(file = "./data/global_reef_fish_biomass.csv",
                                       delim = ",")

```

-   0u bien avec `read_csv` : delimiteur par defaut = virgule

```{r echo=TRUE, eval=FALSE}
global_reef_fish_biomass <- read_csv(file = "./data/global_reef_fish_biomass.csv")
```

## Le ***tibble*** global_reef_fish_biomass

On vérifie sa classe avec `class()`

```{r echo=TRUE, eval=FALSE}
class(global_reef_fish_biomass)
```

## Le ***tibble*** global_reef_fish_biomass

On vérifie sa structure avec `str()`

```{r echo=TRUE, eval=FALSE}
str(global_reef_fish_biomass)
```

## Le ***tibble*** global_reef_fish_biomass

On vérifie son contenu avec `head()`

```{r echo=TRUE, eval=FALSE}
head(global_reef_fish_biomass)
```

## La fonction inverse : `write_...` pour exporter un fichier

-   `write_csv` pour exporter un tibble en csv

```{r echo=TRUE, eval=FALSE}
write_csv(global_reef_fish_biomass, "./data/global_reef_fish_biomass_out.csv")
```

-   ou `write_delim` pour choisir le délimiteur de colonnes (ici tabulation)

```{r echo=TRUE, eval=FALSE}
write_delim(global_reef_fish_biomass, "./data/global_reef_fish_biomass_out2.txt", delim="\t")
```

## Comment lire un fichier avec d'autres séparateurs des colonnes et des décimales ?

-   Pour générer un autre format de fichier, on exporte biomass au format csv "francais" (séparateur décimal=",' et séparateur des colonnes=";")

```{r echo=TRUE, eval=FALSE}
write_csv2(global_reef_fish_biomass, "./data/global_reef_fish_biomass_out3.csv")
```

-   Puis on essaie de lire ce nouveau csv au format francais

## Option 1 : `read_csv2`

```{r echo=TRUE, eval=FALSE}
global_reef_fish_biomass3 <- read_csv2(file = "./data/global_reef_fish_biomass_out3.csv")
str(global_reef_fish_biomass3)
```

## Option 2 : `read_delim` sans préciser le séparateur décimal

PAS BON car les nombres décimaux (ex: biomass) sont lus comme du caractère

```{r echo=TRUE, eval=FALSE}
global_reef_fish_biomass3 <- read_delim(file = "./data/global_reef_fish_biomass_out3.csv",
                                       delim = ";")
str(global_reef_fish_biomass3) 
```

## Option 3 : read_delim en précisant le séparateur décimal avec locale()

```{r echo=TRUE, eval=FALSE}
global_reef_fish_biomass3 <- read_delim(file = "./data/global_reef_fish_biomass_out3.csv",
                                        delim = ";",
                                        locale = locale(decimal_mark = ","))
str(global_reef_fish_biomass3) 
```

## Le type des colonnes

Afficher les specifications avec `spec`

```{r echo=TRUE, eval=FALSE}
spec(global_reef_fish_biomass)
```

Simplifier les specifications avec `col_condense`

```{r echo=TRUE, eval=FALSE}
cols_condense(spec(global_reef_fish_biomass))
```

## Forcer le type d'une colonne

Avec le paramètre `col_types = list(...)`, on choisit de lire survey_id comme un entier `col_integer()`, method et block comme des facteurs `col_factor()`. Pour block on définit aussi des levels avec un certain ordre :

```{r echo=TRUE, eval=FALSE}
global_reef_fish_biomass <- read_csv(file = "./data/global_reef_fish_biomass.csv",
                  col_types = list(survey_id = col_integer(),
                                   method = col_factor(),
                                   block = col_factor(levels=c("3","2","1"))))
spec(global_reef_fish_biomass)

levels(global_reef_fish_biomass$block)

global_reef_fish_biomass <- droplevels(global_reef_fish_biomass)
levels(global_reef_fish_biomass$block)
```

## Importer en ***tibble*** le fichier Survey_metadata.csv

Ce fichier contient des métadonnées caractérisant les campagnes (survey_id) Particularités : séparateur ";" et 70 lignes de commentaires au début qui ne doivent pas être lues : utilisation du paramètre `skip =`

```{r echo=TRUE, eval=FALSE}
survey_metadata <- read_delim(file = "./data/survey_metadata.csv",
                              delim = ";",
                              skip = 70)
head(survey_metadata,3)
```

# Avantages de ***readr*** *vs.* les fonctions de base

## Pour les gros fichiers, ***readr*** est plus rapide

-   Lecture du fichier biomasse avec la fonction `read.csv` de base

```{r echo=TRUE, eval=FALSE}
debut <- Sys.time()
fish1 <- read.delim("./data/global_reef_fish_biomass.csv", 
                   sep = ",")
fin <- Sys.time()
print(paste("L'import a duré : ",
            fin-debut, "secondes"))
```

-   Lecture du même fichier avec `read_csv` de la librairie **readr**

```{r echo=TRUE, eval=FALSE}
debut <- Sys.time()
fish2 <- read_delim(file = "./data/global_reef_fish_biomass.csv", 
                    delim = ",")
fin <- Sys.time()
print(paste("L'import a duré : ",
            fin-debut, "secondes"))

```

## `read_csv` permet de lire depuis une archive, ce que ne permet pas `read.csv`

```{r echo=TRUE, eval=FALSE}
survey_metadata_zip <- read_delim(file = "./data/survey_metadata.zip",
                                  delim = ";",
                                  skip = 70)
```

## `read_csv` permet de lire depuis plusieurs fichiers et mêmes répertoires

```{r echo=TRUE, eval=FALSE}
continents <- c("africa", "americas", "asia", "europe", "oceania")
filepaths <- vapply(
  paste0("mini-gapminder-", continents, ".csv"),
  FUN = readr_example,
  FUN.VALUE = character(1)
)
conti <- read_csv(filepaths, id = "file")

```

## La sélection de colonnes lors de la lecture avec `read_csv` est facilitée

-   Par nom de colonne

```{r echo=TRUE, eval=FALSE}
survey_metadata_1 <- read_delim(file = "./data/survey_metadata.csv",
                                delim = ";",
                                skip = 70,
                                col_select = c(survey_id,country, site_code, site_name))
head(survey_metadata_1)
```

## La sélection de colonnes lors de la lecture avec `read_csv` est facilitée

-   Par numéro de colonne

```{r echo=TRUE, eval=FALSE}
survey_metadata_2 <- read_delim(file = "./data/survey_metadata.csv",
                                delim = ";",
                                skip = 70,
                                col_select = c(1,2,5:8))
head(survey_metadata_2)
```

## La sélection de colonnes lors de la lecture avec `read_csv` est facilitée

-   Par numéro de colonne, en omettant certaines colonnes

```{r echo=TRUE, eval=FALSE}
survey_metadata_3 <- read_delim(file = "./data/survey_metadata.csv",
                                delim = ";",
                                skip = 70,
                                col_select = -c(11:22,24))
head(survey_metadata_3)
```

## On peut renommer certaines colonnes

NB : ne pas oublier `everything()` pour conserver à l'identique toutes les colonnes non renommées

```{r echo=TRUE, eval=FALSE}
survey_metadata_4 <- read_delim(file = "./data/survey_metadata.csv",
                                delim = ";",
                                skip = 70,
                                col_select = c(projet = survey_id, pays = country, everything()))
head(survey_metadata_4)

```

## On peut faire un filtre en entrée sur les valeurs d'une colonne avec `read_..._chunked`

-   Pour sélectionner sur une colonne (ici la famille)

```{r echo=TRUE, eval=FALSE}
f1 <- function(x, pos) subset(x, family %in% c("Kyphosidae", "Labridae", "Sparidae"))
kyphosidae_labridae_sparidae_biomass <- read_csv_chunked(file = "./data/global_reef_fish_biomass.csv", 
                               callback = DataFrameCallback$new(f1), 
                               chunk_size = 1000)
table(kyphosidae_labridae_sparidae_biomass$family)
```

## On peut faire un filtre en entrée sur les valeurs d'une colonne avec `read_..._chunked`

-   Pour sélectionner sur plusieurs colonnes (ici la famille et la classe de taille)

```{r echo=TRUE, eval=FALSE}
f2 <- function(x, pos) subset(x, family == "Kyphosidae" & size_class>9 & size_class < 31)
kyphosidae_10_30_cm_biomass <- read_csv_chunked(file = "./data/global_reef_fish_biomass.csv", 
                                       callback = DataFrameCallback$new(f2), 
                                       chunk_size = 1000)
table(kyphosidae_10_30_cm_biomass$family, kyphosidae_10_30_cm_biomass$size_class)
```

## Exercice 1.1 {auto-animate="true"}

-   Lire le fichier Survey_metadata.csv =\> tibble `survey_metadata`,
-   Lire le fichier Global_reef_fish_biomass.csv =\> tibble `global_reef_fish_biomass`
-   Lire le fichier Global_reef_fish_abundance.csv =\> tibble `global_reef_fish_abundance`

```{r echo=TRUE, eval=FALSE}
# solution
```

## Exercice 1.1 corrigé {auto-animate="true"}

-   Lire le fichier Survey_metadata.csv =\> tibble `survey_metadata`,
-   Lire le fichier Global_reef_fish_biomass.csv =\> tibble `global_reef_fish_biomass`

```{r echo=TRUE, eval=FALSE}
# solution
global_reef_fish_biomass <- read_csv(file = "./data/global_reef_fish_biomass.csv")
survey_metadata <- read_delim(file = "./data/survey_metadata.csv",
                              delim = ";",
                              skip = 70)
```

## Exercice 1.2 {auto-animate="true"}

Lire le fichier Survey_metadata.csv =\> tibble `Survey_selection` en sélectionnant le pays=Indonésie, la profondeur inférieure à 20m et la visibilité supérieure à 10m.

```{r echo=TRUE, eval=FALSE}
# solution
```

## Exercice 1.2 corrigé {auto-animate="true"}

Lire le fichier Survey_metadata.csv =\> tibble `Survey_selection` en sélectionnant le pays Indonésie, la profondeur inférieure à 20m et la visibilité supérieure à 10m.

```{r echo=TRUE, eval=FALSE}
# solution
f3 <- function(x, pos) subset(x, country == "Indonesia" & depth<20 & visibility>10 )
survey_selection <- read_delim_chunked(file = "./data/survey_metadata.csv", 
                                       callback = DataFrameCallback$new(f3), 
                                       chunk_size = 1000,
                                       delim = ";",
                                       skip = 70)
dim(survey_selection)
```

# Partie 2 : Manipulation de données avec dplyr

![](images/dplyr_logo.png)

## [dplyr](https://dplyr.tidyverse.org/){target="_blank"}

### Pourquoi utiliser dplyr et ca syntaxe ?

-   Syntaxe claire et cohérente
    -   "lien" avec le SQL
    -   deux "familles" de fonctions : résumé et vectorisation <br/> <br/> <br/> ![](images/summary_function.png){.absolute top="320" left="15"} ![](images/vectorized_function.png){.absolute top="320" right="15"}
-   Utilisation de verbes
-   Généralement plus rapides que leur équivalent sous R de base
-   Permets d'enchainer les opérations avec des "pipes" ![](images/pipe.png){.absolute top="450" right="20" width="15%"}

## Manipulation des lignes

### Manipulation de type extraction

Type de fonctions qui retournent un sous-ensemble de lignes

-   Extraction d'une ou plusieurs lignes : fonctions de la famille slice & co

```{r echo=TRUE, eval=FALSE}
# sélection d'une ou plusieurs lignes par position absolue
slice()
# sélection au hasard d'un nombre de lignes ou d'une proportion du jeu de données
slice_sample()
# sélection des n dernières lignes
slice_tail()
# sélection des n premières lignes
slice_head()
# sélection des valeurs distinctes
distinct()
# sélection en fonction d'opérateurs logiques et/ou booléens
filter()
```

## Petit focus sur les opérateurs booléens et logiques {.smaller}

Renvoient une valeur TRUE ou FALSE

-   les communs :

![](images/booleens.png)

-   certains plus particuliers :

![](images/booleens_particulier.png){width="25%"}

-   Attention aux priorités dans les interprétations
    -   & est plus fort que \|, il sera exécuté en premier
    -   une solution est d'utiliser des () pour séparer vos opérateurs

## Exercice 2.1 {auto-animate="true"}

-   A l'aide d'une fonction dplyr, vérifier s'il y a des données dupliquées dans le jeu de données "global_reef_fish_biomass"
-   En une seule fois, selectionner les données dont la variable "total" est différent de 0, où la famille de l'espèce est différente de "Mullidae" ou "Apogonidae" et pour finir où la classe de taille associée est \<= 10.

```{r echo=TRUE, eval=FALSE}
# solution
```

## Exercice 2.1 corrigé {auto-animate="true"}

-   A l'aide d'une fonction dplyr, vérifier s'il y a des données dupliquées dans le jeu de données "global_reef_fish_biomass"
-   En une seule fois, selectionner les données dont la variable "total" est différent de 0, où la famille de l'espèce est différente de "Mullidae" ou "Apogonidae" et pour finir où la classe de taille associée est \<= 10.

```{r echo=TRUE, eval=FALSE}
# solution
biomass_exercice2_1_distinct <- distinct(.data = global_reef_fish_biomass)
biomass_exercice2_1_filter <- filter(.data = biomass_exercice2_1_distinct,
                                     biomass != 0
                                     & ! family %in% c("Mullidae",
                                                       "Apogonidae")
                                     & size_class <= 10)
```

## Amélioration de la lisibilité du code

Ici on a effectué 2 opérations, mais on peut imaginer en faire beaucoup plus dans la réalité.

Grâce à la syntaxe de dplyr, on peut répondre à ce besoin de deux manières différentes.

La première est d'effectuer toutes les opérations en une fois en les emboîtant :

```{r echo=TRUE, eval=FALSE}
biomass_exercice2_1_distinct_filter <- filter(.data = distinct(.data = global_reef_fish_biomass),
                                              biomass != 0
                                              & ! family %in% c("Mullidae",
                                                                "Apogonidae")
                                              & size_class <= 10)
```

Cependant cela a plusieurs inconvénients. La structure est peu lisible, les opérations apparaissent dans l'ordre inverse de leur réalisation et il est difficile de voir quel paramètre se rapporte à quelle fonction.

## Aller encore plus loin

### Utilisation d'un nouvelle opérateur baptisé [pipe](https://magrittr.tidyverse.org/){target="_blank"}

-   Il se note %\>%

-   Son fonctionnement est le suivant : si j'exécute expr %\>% f, le résultat de l'expression expr, à gauche du pipe, sera passé comme premier argument à la fonction f, à droite du pipe, ce qui revient à exécuter f(expr)

-   L'intérêt est que l'on peut enchainer plusieurs pipes

-   Avec notre exemple précédent cela donne :

```{r echo=TRUE, eval=FALSE}
biomass_exercice2_1_distinct_filter <- distinct(.data = global_reef_fish_biomass) %>%
  filter(biomass != 0
         & ! family %in% c("Mullidae",
                           "Apogonidae")
         & size_class <= 10)
```

## Encore quelques fonctions de manipulation de lignes

### Manipulation de type "tri"

-   Ordonner les lignes d'une ou plusieurs colonnes

```{r echo=TRUE, eval=FALSE}
# par défaut ordre croissant, utiliser l'argument desc pour ordre décroissant
arrange()
```

<br/>

### Manipulation de type "ajout"

-   Ajouter une ligne dans un jeu de données

```{r echo=TRUE, eval=FALSE}
# interet des arguments .before and .after
add_row()
```

## Manipulation des variables

### Extraction d'une ou plusieurs colonnes

Type de fonctions qui retournent un sous-ensemble de colonnes sous la forme d'un vecteur ou d'une table

```{r echo=TRUE, eval=FALSE}
# extraction des valeurs d'une colonne sous la forme d'un vecteur
# on peut utiliser des noms ou les ids
pull()
# extraction d'une colonne sous la forme d'une table
# bien regarder les arguments de la fonction car on peut faire beaucoup
select()
# Changer l'ordre ou la place d'une ou plusieurs colonnes
# ne pas oublier les arguments .after et .before
relocate()
```

## Fonctions de vectorisation

### Une des deux grandes familles de fonction avec dplyr

-   On a commencé à l'aborder de manière instinctive avec relocate()

-   Globalement, ce sont des fonctions qui ont un vecteur en entrée et retournent un vecteur de la même taille en sortie <br/> <br/> <br/> ![](images/vectorized_function.png){.absolute top="300" left="250" width="50%"}

```{r echo=TRUE, eval=FALSE}
# créer une nouvelle variable
mutate()
# créer une nouvelle variable mais sans conserver les anciennes
transmute()
```

-   Petit bonus pour renommer les variables

```{r echo=TRUE, eval=FALSE}
rename()
```

## Exercice 2.2 {.smaller auto-animate="true"}

-   À partir du jeu de données de sortie de l'exercice 1
-   Créer une variable "survey_id_full" qui est la concaténation des variables survey_id, species_name et size_class
-   Placer cette nouvelle colonne avant la colonne survey_id
-   Supprimer la quatrième colonne du jeu de données (utiliser son indice) ainsi que la colonne reporting_name
-   Renommer la variable size_class en size_class_cm
-   Créer une nouvelle variable size_class_mm qui convertit la variable size_class_cm en mm
-   Supprimer la variable size_class_cm
-   Trier par ordre décroissant les données en fonction de la variable size_class_mm
-   Utiliser des pipes à la fin pour avoir une syntaxe "propre" et souffler un bon coup :)

```{r echo=TRUE, eval=FALSE}
# solution
```

## Exercice 2.2 corrigé {.smaller auto-animate="true"}

-   À partir du jeu de données de sortie de l'exercice 1
-   Créer une variable "survey_id_full" qui est la concaténation des variables survey_id, species_name et size_class
-   Placer cette nouvelle colonne avant la colonne survey_id
-   Supprimer la quatrième colonne du jeu de données (utiliser son indice) ainsi que la colonne reporting_name
-   Renommer la variable size_class en size_class_cm
-   Créer une nouvelle variable size_class_mm qui convertit la variable size_class_cm en mm
-   Supprimer la variable size_class_cm
-   Trier par ordre décroissant les données en fonction de la variable size_class_mm
-   Utiliser des pipes à la fin pour avoir une syntaxe "propre" et souffler un bon coup :)

```{r echo=TRUE, eval=FALSE}
# solution
biomass_exercice2_2 <- mutate(.data = biomass_exercice2_1_distinct_filter,
                              survey_id_full = paste(survey_id,
                                                     species_name,
                                                     size_class,
                                                     sep = "_")) %>%
  relocate(survey_id_full,
           .before = survey_id) %>%
  dplyr::select(-4,
                -reporting_name) %>%
  rename(size_class_cm = size_class) %>%
  mutate(size_class_mm = size_class_cm * 10) %>%
  dplyr::select(-size_class_cm) %>%
  arrange(desc(size_class_mm))
```

## Fonctions de resumé {.smaller}

### La deuxième grande famille

-   Fonctions qui vont créer une nouvelle table avec des resumés statistiques. De manière globale, les fonctions associées vont utiliser en entrée des vecteurs et en sortie une ou plusieurs valeurs ( en nombre inférieur au nombre de vecteurs d'entrée) <br/> <br/> <br/> ![](images/summary_function.png){.absolute top="200" left="250" width="50%"}

-   Fonction clé

```{r echo=TRUE, eval=FALSE}
summarise()
# Beaucoup, beaucoup d'options et de possibilités
# Compter le nombre de valeurs/lignes
n()
# Compter le nombre de valeurs/lignes distinctes
n_distinct()
# Faire une moyenne
mean()
# Faire une somme, option na.rm disponible
sum()
# Utiliser des notions de position
first()
last()
# Ou de rang
quantile()
min()
max()
```

## Introduction à la notion de groupe

-   Pour le moment on a fait des opérations sur l'ensemble du jeu de données, pas très pertinent non ?

-   Fonction de création de groupe

```{r echo=TRUE, eval=FALSE}
# on peut définir nos groupes en fonction des modalités des variables
group_by()
# ou alors en isolant chaque ligne
rowwise()
```

-   Attention à ce que vous faites ! Par défaut, les groupes sont gardés en mémoire dans votre jeu de données de sortie (lisez les messages de R). Pour y remédier :

```{r echo=TRUE, eval=FALSE}
# via un summarise (argument experimental, attention à la pérennité)
.groups
# de manière plus générale
ungroups()
```

-   Cette notion de groupe peut être utilisée avec d'autres fonctions (comme un mutate)

## Exercice 2.3 {.smaller auto-animate="true"}

-   À partir du jeu de données de sortie de l'exercice 2
-   Effectuer la somme de la biomasse (variable biomass) en fonction de la variable survey_id_full créée précédemment
-   Pour survey_id_full répétés, ne garder que la première ligne de chaque répétition. Attention à bien conserver toutes les colonnes associées (une fois la fonction "trouvée" regarder du côté des arguments en option)
-   Créer un nouveau jeu de données qui exprime le nombre d'échantillons disponibles par famille et vérifier la cohérence du nombre total obtenu avec le jeu de données de départ.

```{r echo=TRUE, eval=FALSE}
# solution
```

## Exercice 2.3 corrigé {.smaller auto-animate="true"}

-   À partir du jeu de données de sortie de l'exercice 2
-   Effectuer la somme de la biomasse (variable biomass) en fonction de la variable survey_id_full créée précédemment
-   Pour survey_id_full répétés, ne garder que la première ligne de chaque répétition. Attention à bien conserver toutes les colonnes associées (une fois la fonction "trouvée" regarder du côté des arguments en option)
-   Créer un nouveau jeu de données qui exprime le nombre d'échantillons disponibles par famille et vérifier la cohérence du nombre total obtenu avec le jeu de données de départ.

```{r echo=TRUE, eval=FALSE}
# solution
biomass_exercice2_3 <- biomass_exercice2_2 %>%
  dplyr::group_by(survey_id_full) %>%
  mutate(sum_biomass = sum(x = biomass)) %>%
  ungroup() %>%
  distinct(survey_id_full,
           .keep_all = TRUE)

biomass_exercice2_3_sample_verification <- dplyr::group_by(.data = biomass_exercice2_2,
                                                           family) %>%
  summarise(nb_sample_family = n()) %>%
  mutate(total = sum(nb_sample_family))
```

## Fonction bonus très utile {.smaller}

### case_when : généralisation vectoriseé de if(s)

-   Vectorisation de multiples if_else sous R et CASE WHEN en SQL
-   Améliore grandement la lisibilité de vos fonctions
-   Syntaxe de base :

```{r echo=TRUE, eval=FALSE}
case_when(
  operateur(s) booléen(s) ou logique(s) ~ output1,
  operateur(s) booléen(s) ou logique(s) ~ output2,
  ....
  operateur(s) booléen(s) ou logique(s) ~ output_n,
  TRUE ~ output si rien ne marche au dessus
)
```

-   Pensez bien à toujours mettre un TRUE (=valeur par défaut)
-   Attention à ne pas mélanger les types, il existe différent NA :
    -   NA_integer\_
    -   NA_real\_
    -   NA_complex\_
    -   NA_character\_

## Combinaison de jeux de données 1

### Jointures "simples"

-   Il doit y avoir une cohérence entre le nombre de colonnes ou de lignes
-   Attention, aucune vérification de cohérence des jointures

```{r echo=TRUE, eval=FALSE}
# "Coller" deux jeux de données
bind_cols()
bind_rows()
```

## Combinaison de jeux de données 2 {.smaller}

### Jointures de type relationnel

::: columns
::: {.column width="70%"}
-   Très proche du SQL
-   Très puissantes et permettent de se poser les bonnes questions !
-   Attention à bien spécifier l'argument by (ne pas laisser place à l'interprétation !)
    -   On peut spécifier une seule ou plusieurs colonnes si les noms sont identiques entre les deux jeux de données
    -   Sinon on spécifie le nom du jeu de données à "gauche" et celui qui est à "droite"
:::

::: {.column width="30%"}
![](images/jointure.png)
:::
:::

```{r echo=TRUE, eval=FALSE}
# jointure à gauche
left_join()
# jointure à droite
right_join()
# jointure commune
inner_join()
# jointure complete
full_join()
```

## Exercice 2.4 {.smaller auto-animate="true"}

-   À partir du jeu de données de sortie de l'exercice 2.3 (biomass_exercice2_3)
-   Faire la "meilleure" jointure avec le jeu de données survey_metadata et expliquer votre choix
-   Pour vous aider :
    -   Y-a-t-il un problème avec le jeu de données survey_metadata ?
    -   Réfléchissez en termes du nombre de lignes obtenues pour chaque fonction de jointure

```{r echo=TRUE, eval=FALSE}
# solution
```

## Exercice 2.4 corrigé {.smaller auto-animate="true"}

-   À partir du jeu de données de sortie de l'exercice 2.3 (biomass_exercice2_3)
-   Faire la "meilleure" jointure avec le jeu de données survey_metadata et expliquer votre choix
-   Pour vous aider :
    -   Y-a-t-il un problème avec le jeu de données survey_metadata ?
    -   Réfléchissez en termes du nombre de lignes obtenues pour chaque fonction de jointure

```{r echo=TRUE, eval=FALSE}
# solution
survey_metadata_distinct <- distinct(.data = survey_metadata)
biomass_survey_exercice2_4 <- biomass_exercice2_3 %>%
  left_join(survey_metadata_distinct,
             by = "survey_id")

save(biomass_survey_exercice2_4, file = "./data/biomass_survey_exercice2_4.RData")
```

# Partie 3 : Nettoyage des données avec `tidyr`

<center>

![](images/logo_tidyr.png){width="20%"}

<center>

## 

L'objectif du package tidyr est de fournir des fonctions pour arranger et nettoyer ses données dans le but de les convertir dans un format "tidy"

Les différents verbes viennent s'ajouter à tous ceux que nous avons déjà vus avec readr et dplyr et ils s'intègrent parfaitement dans la série de pipe %\>% permettant d'enchainer les opérations

-   Les données "tidy", qu'est ce que c'est?

    -   1 variable = 1 colonne

    -   1 observation = 1 ligne/case

    -   1 type d'observations par table

Pour visualiser le cheatsheet `tidyr` [cliquez ici](https://github.com/rstudio/cheatsheets/blob/main/tidyr.pdf)

```{r echo=TRUE, eval=FALSE}
# Pour illustrer cette partie nous utiliserons le jeu de données popEU
popEU <- read_rds("./data/popEU.rds")
dim(popEU)
popEU
```

## Les principaux verbes de la librairie tidyr {.smaller}

### Modelage des tableaux

`pivot_wider()`et `pivot_longer()`sont les successeurs des fonctions en base R du package `reshape` puis `reshape2`. Et se nommaient `spread()`et `gather()` dans les premières versions de `tidyr`

::: incremental
-   Transformer un tableau long en format large

    ```{r echo=TRUE, eval=FALSE}
    # Les arguments names_from et values_from renseignent les noms de colonnes 
    # à partir desquelles nous obtenons les colonnes de sortie et les valeurs des cellules
    pivot_wider(names_from, values_from)
    # L'argument values_fill permet de spécifier une valeur que l'on choisit 
    # quand la combinaison names_from/values_from est manquante. Par défaut NA
    ```

-   Transformer un tableau large en format long

    ```{r echo=TRUE, eval=FALSE}
    # Les arguments cols, names_to et values_to renseignent les noms de colonnes à créer ainsi que les colonnes à faire pivoter
    pivot_longer(cols, names_to, values_to, ...)
    # Si l'argument values_drop_na = TRUE les lignes contenant des NA dans la colonne créée avec values_to seront supprimées. 
    #Par défaut FALSE
    ```
:::

##  {.smaller}

-   Applications

    -   Transformer le jeu de données en format "wide" en utilisant la fonction `pivot_wider()`. Nous voulons obtenir une colonne par année

```{r echo=TRUE, eval=FALSE}
# Créer un nouvel objet que l'on nomme popEU_wide
popEU_wide <- pivot_wider(popEU,names_from="year",values_from="pop")
dim(popEU_wide)
kable(popEU_wide, html_font = "Computer Modern", table.attr = "style='width:60%;'")
```

## 

### Gestion des valeurs manquantes "NA"

::: incremental
-   Remplacer des "NA" par des valeurs spécifiques

    ```{r echo=TRUE, eval=FALSE}
    # Si la donnée est un data frame alors l'argument replace prend une liste de valeurs. 
    # Si la donnée est un vecteur alors replace prend une seule valeur
    replace_na(data, replace, …)
    ```

-   Supprimer les lignes contenant des "NA"

    ```{r echo=TRUE, eval=FALSE}
    # Il est possible en 2ème argument de spécifier le nom d'une colonne en particulier
    drop_na(data, …)
    ```

-   Remplir les "NA" en utilisant les valeurs précédentes ou suivantes de la même colonne

    ```{r echo=TRUE, eval=FALSE}
    # Importance de l'argument .direction ("down","up","updown","downup")
    fill(data, …, .direction)
    ```
:::

##  {.smaller}

-   Applications

::: incremental - Re-transformer le jeu de données en format "long" en utilisant la fonction `pivot_longer()` et remplacer les valeurs de NA dans la colonne "pop", par la population moyenne de la Belgique pour ces 2 années (11,27 M)

    ```{r echo=TRUE, eval=FALSE}
    # Créer un nouvel objet que l'on nomme popEU_long
    popEU_long <- pivot_longer(popEU_wide,cols=c(2:4),names_to="year",values_to="pop")
    dim(popEU_long)
    # Afficher popEU_long
    kable(popEU_long[10:15,], html_font = "Computer Modern", table.attr = "style='width:60%;'")

    popEU_long <- mutate(popEU_long,pop = replace_na(pop,11.27))
    kable(popEU_long[10:15,], html_font = "Computer Modern", table.attr = "style='width:60%;'")
    ```

    -   Re-transformer le jeu de données en format "long" en utilisant la fonction \`pivot_longer()\` et supprimer les lignes contenant des NA dans la colonne pop. Essayer d'enchainer les opérations à l'aide du pipe %\\\>%

    ```{r echo=TRUE, eval=FALSE}
    # Créer un nouvel objet que l'on nomme popEU_long
    popEU_long <- popEU_wide %>%
      tidyr::pivot_longer(.,cols=c(2:4),names_to="year",values_to="pop") %>%
      drop_na(.,pop)
    dim(popEU_long)
    ```

    -   Re-transformer le jeu de données en format "long" en utilisant la fonction \`pivot_longer()\` et compléter les valeurs manquantes par la valeur du pays correspondant. Essayer d'enchainer les opérations à l'aide du pipe %\\\>%

    ```{r echo=TRUE, eval=FALSE}
    # Créer un nouvel objet que l'on nomme popEU_long
    popEU_long <- popEU_wide %>%
      tidyr::pivot_longer(.,cols=c(2:4),names_to="year",values_to="pop") %>%
      fill(.,pop,.direction="down")

    kable(popEU_long[10:15,], html_font = "Computer Modern", table.attr = "style='width:60%;'")
    ```
    :::

## 

### Combinaison des variables

::: incremental
-   Séparer une colonne en plusieurs colonnes

    ```{r echo=TRUE, eval=FALSE}
    # par défaut le séparateur est un caractère non alpha-numérique. 
    #Si l'on souhaite un autre séparateur il faut le spécifier aec l'argument sep
    separate(data, col, into)
    ```

-   Créer une seule colonne à partir de plusieurs colonnes

    ```{r echo=TRUE, eval=FALSE}
    unite(col, ..., sep)
    ```

-   Générer toutes les combinaisons 2 à 2 possibles entre les variables définies

    ```{r echo=TRUE, eval=FALSE}
    expand(data, ...)
    ```
:::

##  {.smaller}

-   Applications

::: incremental 

    - A partir du dernier popEU_long généré, transformer la colonne pop en caractères et créer deux nouvelles "millions" et "milliers"

    ```{r echo=TRUE, eval=FALSE}
    popEU_sep <- popEU_long %>%
    mutate(pop = as.character(pop))%>%
    separate(.,col=pop,into=c("millions","milliers"))

    kable(popEU_long[1:5,], html_font = "Computer Modern", table.attr = "style='width:60%;'")
    ```

    -   Recréer la colonne pop comme à l'origine en la nommant population

    ```{r echo=TRUE, eval=FALSE}
    popEU_unite <- popEU_sep %>%
    unite(.,population,c(millions,milliers),sep=".")

    kable(popEU_unite[1:5,], html_font = "Computer Modern", table.attr = "style='width:60%;'")
    ```

    -   Générer un tableau avec toutes les combinaisons possibles pays/population

    ```{r echo=TRUE, eval=FALSE}
    popEU_expand <- popEU_unite %>%
    expand(.,pays,population)
    popEU_expand

    kable(popEU_expand[1:5,], html_font = "Computer Modern", table.attr = "style='width:60%;'")
    # Que remarquons nous ?
    ```

<center>

La valeur 11.21 n'apparait qu'une seule fois, ce sont bien les combinaisons uniques.\<\center\> 

:::

## Exercice 3.1 {.smaller auto-animate="true"}

-   Chargez les données d'abondance. Les données sont elles Tidy ?

```{r echo=TRUE, eval=FALSE}
# solution
```

## Exercice 3.1 corrigé {.smaller auto-animate="true"}

-   Chargez les données d'abondance. Les données sont elles Tidy ?

```{r echo=TRUE, eval=FALSE}
# solution
abundance <- read_delim(".data/Global_reef_fish_abundance.csv")
# Non les données ne sont pas tidy, car elles sont en format wide
```

## Exercice 3.2 {.smaller auto-animate="true"}

-   Transformez les en format tidy. Les nouvelles colonnes seront "sp_size" et "abundance"
-   Créez une nouvelle variable "survey_id_full" qui est l'union entre le survey_id et sp_size avec comme séparateur un "\_". Pensez à enchainer les opérations

```{r echo=TRUE, eval=FALSE}
# solution
```

## Exercice 3.2 corrigé {.smaller auto-animate="true"}

-   Transformez les en format tidy. Les nouvelles colonnes seront "sp_size" et "abundance"
-   Créez une nouvelle variable "survey_id_full" qui est l'union entre le survey_id et sp_size avec comme séparateur un "\_". Pensez à enchainer les opérations

```{r echo=TRUE, eval=FALSE}
# solution
# Attention à l'argument values_dop_na
abundance_long <- abundance %>%
  pivot_longer(.,cols=2:17523,names_to="sp_size",values_to="abundance",values_drop_na = TRUE) %>%
  unite(.,col="survey_id_full",c(survey_id,sp_size),sep="_")
```

## Exercice 3.3 {.smaller auto-animate="true"}

-   Créez un seul tableau regroupant biomasse et abondance

```{r echo=TRUE, eval=FALSE}
# solution
```

## Exercice 3.3 corrigé {.smaller auto-animate="true"}

-   Créez un seul tableau regroupant biomasse et abondance

```{r echo=TRUE, eval=FALSE}
# solution
biomass_abundance <- biomass %>%
  left_join(.,abundance_long,by="pk")
```

## Exercice 3.4 {.smaller auto-animate="true"}

-   Créez 2 nouvelles colonnes "genus" et "species" à partir de species_name

```{r echo=TRUE, eval=FALSE}
# solution
```

## Exercice 3.4 corrigé {.smaller auto-animate="true"}

-   Créez 2 nouvelles colonnes "genus" et "species" à partir de species_name

```{r echo=TRUE, eval=FALSE}
# solution
biomass_abundance <- biomass_abundance %>%
  separate(.,species_name,into = c("genus","species"))
```

## Exercice 3.5 {.smaller auto-animate="true"}

-   Transformez le tibble en sf object avec la commande sf::st_as_sf(survey,coords =c("latitude","longitude") ,remove=FALSE).

```{r echo=TRUE, eval=FALSE}
# solution
```

## Exercice 3.5 corrigé {.smaller auto-animate="true"}

-   Transformez le tibble en sf object avec la commande sf::st_as_sf(survey,coords =c("latitude","longitude") ,remove=FALSE).

```{r echo=TRUE, eval=FALSE}
# solution
data_sf <- sf::st_as_sf(biomass_abundance,coords =c("latitude","longitude") ,remove=FALSE)
```

## Exercice 3.6 {.smaller auto-animate="true"}

-   Corrigez l'erreur

```{r echo=TRUE, eval=FALSE}
# solution
```

## Exercice 3.6 corrigé {.smaller auto-animate="true"}

-   Corrigez l'erreur

```{r echo=TRUE, eval=FALSE}
# solution
biomass_survey_abundance_exercice3_6 <- biomass_abundance %>%
  drop_na(latitude) %>%
  drop_na(longitude) %>%
  sf::st_as_sf(.,coords =c("latitude","longitude"), remove=FALSE)

save(biomass_survey_abundance_exercice3_6, file = "./data/biomass_survey_abundance_exercice3_6.RData")
```

# Partie 4 : Extension à la manipulation de données, cas spécifiques

![](images/logo_stringr.png){.absolute top="300" width="20%"} ![](images/logo_lubridate.png){.absolute top="300" left="300" width="20%"}

## 4.1 : Manipuler du texte avec stringr

Conçu pour manipuler les chaines de caractères "facilement". <br>En plus d'être plus faciles à utiliser, le nom des fonctions dans\
`stringr` représentent bien ce qu'elles permettent de faire.

![](images/logo_stringr.png){.absolute top="40" right="20" width="15%"}

. . .

Le nom de toutes les fonctions dans `stringr` commence par `str_`.

. . .

Voici quelques exemples :

::: columns
::: {.column width="50%"}
::: incremental
-   `str_detect` : Détection de caractères

-   `str_extract` : Extraction de caractères

-   `str_replace` : Remplacement de caractères
:::
:::

::: {.column width="50%"}
::: incremental
-   `str_trim` : Enlève les espaces

-   `str_split` : Sépare une chaine de caractères

-   `str_length` : Nombre de caractère
:::
:::
:::

. . .

<center>Le cheat-sheet du package `stringr` est disponible [ici](https://github.com/rstudio/cheatsheets/blob/main/strings.pdf).</center>

## Création d'un dataframe de chaines de caractères

```{r}
tmp <- tibble(nom = c("Micheline Sétou", "Jean-Jacques Apeprès",  "Martine Sérien"),
              num_rue = c("12", "15 ou 16", "NA"), 
              nom_rue = c("Rue des peupliers", "Rue + un arbre", "NA"),
              ville = c("Montpellier", "Montpellier", "Montpellier"))

kable(tmp, html_font = "Computer Modern", table.attr = "style='width:60%;'")
```

## Détection de caractères

On utilise la fonction `str_detect()` et les deux arguments principaux :

::: incremental
-   `string` : Le/Les caractère(s) qui vont passer au détecteur.
-   `pattern` : Le caractère à détecter.
:::

. . .

La fonction renvoie `TRUE` ou `FALSE` en fonction de la présence ou non du caractère.

. . .

### Exemple

::: columns
::: {.column width="50%"}
```{r results='hide'}
tmp$nom
```

```{r echo = FALSE}
cat(tmp$nom, sep = "\n")
```
:::

::: {.column width="50%"}
```{r results='hide'}
str_detect(string  = tmp$nom, pattern = "ine")
```

```{r echo = FALSE}
cat(str_detect(string  = tmp$nom, 
           pattern = "ine"), sep = "\n")
```
:::
:::

. . .

<center>

La fonction `str_detect()` peut donc être utilisée avec `filter()` pour faire une <br> sélection des lignes qui nous intéresse dans le tableau.

## Sous-sélection de certains caractères

On utilise la fonction `str_subset()` et les deux arguments principaux :

::: incremental
-   `string` : Le/Les caractère(s) qui vont passer au détecteur.
-   `pattern` : Le caractère à détecter.
:::

. . .

Contrairement à `str_detect()`, la fonction `str_subset()` renvoie les caractères qui contiennent le pattern à détecter.

. . .

### Exemple

```{r}
str_subset(string  = tmp$nom, 
           pattern = "ine")
```

## Extraction de caractères

On utilise la fonction `str_extract()` et ses arguments principaux :

::: incremental
-   `string` : Le/Les caractère(s) qui vont passer à l'extracteur.
-   `pattern` : Le caractère à extraire.
:::

. . .

### Exemple

::: columns
::: {.column width="50%"}
```{r results='hide'}
tmp$ville
```

```{r echo = FALSE}
cat(tmp$ville, sep = "\n")
```
:::

::: {.column width="50%"}
```{r results='hide'}
str_extract(string  = tmp$ville, 
            pattern = "Montpel")
```

```{r echo = FALSE}
cat(str_extract(string  = tmp$ville, 
                pattern = "Montpel"), sep = "\n")
```
:::
:::

## Remplacer un caractère par un autre

On utilise la fonction `str_replace()` et ces arguments principaux :

::: incremental
-   `string` : Le/Les caractère(s) qui vont passer à l'extracteur.
-   `pattern` : Le caractère à remplacer.
-   `replacement` : Le caractère de remplacement.
:::

. . .

### Exemple

::: columns
::: {.column width="50%"}
```{r results='hide'}
# Les noms avant le replacement
tmp$nom

```

```{r echo = FALSE}
cat(tmp$nom, sep = "\n")
```
:::

::: {.column width="50%"}
```{r results='hide'}
str_replace(string      = tmp$nom, 
            pattern     = "Jacques", 
            replacement = "Michel")
```

```{r echo = FALSE}
cat(str_replace(string      = tmp$nom, 
                pattern     = "Jacques", 
                replacement = "Michel"), sep = "\n")
```
:::
:::

## Concaténer des chaînes de caractères {auto-animate="true"}

On utilise la fonction `str_glue()` et ces deux principaux arguments :

::: incremental
-   Le/les expressions à assembler entre `""`. Quand on veut ajouter l'information issue d'un data.frame, on met entre `{}`.
-   `.sep` = le séparateur
:::

. . .

### Exemple sur une ligne du data.frame

```{r}
str_glue("{tmp$nom[1]} habite au {tmp$num_rue[1]} {tmp$nom_rue[1]}", .sep = " ")
```

## Concaténer des chaînes de caractères {auto-animate="true"}

On utilise la fonction `str_glue()` et ces deux principaux arguments :

-   Le/les expressions à assembler entre `""`. Quand on veut ajouter l'information issue d'un data.frame, on met entre `{}`.
-   `.sep` = le séparateur

### Exemple sur une ligne du data.frame

```{r}
str_glue("{tmp$nom[1]} habite au {tmp$num_rue[1]} {tmp$nom_rue[1]}", .sep = " ")
```

### Exemple pour tout un data.frame

```{r}
str_glue_data(tmp, "{nom}, habite au {num_rue} {nom_rue} dans la ville de {ville}")
```

## Exercice 4.1.1 {auto-animate="true"}

**Question 1** : Dans le fichier biomass_survey_abundance_exercice3_6.RData, filter les données qui mentionnent la Méditerranée dans la colonne location.

. . .

**Question 2** : A partir de la colonne location, créer une colonne qui extrait l'orientation. La colonne orientation doit être homogène, donc pas d'espace, ni de parenthèses.

. . .

**Question 3** : A partir du fichier global_reef_fish_biomass.csv chargé avec `read_delim()`, enchaîner le pipe pour obtenir un data.frame résumant le nombre d'observations dans chacune des classes, pour le site n°2000951 seulement.

. . .

**Question 4** : Résolvez le problème de façon à obtenir un tibble de dimension 2x2.

## Exercice 4.1.1 - Correction Q1 {auto-animate="true"}

**Question 1** : Dans le fichier survey_metadata.csv, filter les données qui mentionnent la Méditerranée dans la colonne location.

```{r}
load("biomass_survey_abundance_exercice3_6.RData")
survey_med <- biomass_survey_abundance_exercice3_6 %>%
  filter(str_detect(location, "Mediterranean") == TRUE)
```

## Exercice 4.1.1 - Correction Q2

**Question 2** : A partir de la colonne location, créer une colonne qui extrait l'orientation. La colonne orientation doit être homogène, donc pas d'espace, ni de parenthèses. Enregistrer le **survey_med** au format .RData

. . .

Solution décomposée

```{r}
survey_med <- biomass_survey_abundance_exercice3_6 %>%
  filter(str_detect(location, "Mediterranean") == TRUE) %>%
  mutate(orientation = word(location, 2, -1)) %>%
  mutate(orientation = str_replace(orientation, " ", "")) %>%
  mutate(orientation = str_replace(orientation, "\\(", "")) %>%
  mutate(orientation = str_replace(orientation, "\\)", ""))
```

. . .

```{r}
kable(survey_med[1:3, "orientation"], html_font = "Computer Modern", table.attr = "style='width:50%;'")
```


## Exercice 4.1.1 - Correction Q2

**Question 2** : A partir de la colonne location, créer une colonne qui extrait l'orientation. La colonne orientation doit être homogène, donc pas d'espace, ni de parenthèses. Enregistrer le **survey_med** au format .RData

. . .

Solution plus courte

```{r}
survey_med <- biomass_survey_abundance_exercice3_6 %>%
  filter(str_detect(location, "Mediterranean") == TRUE) %>%
  mutate(orientation = str_replace_all(word(location, 2, -1),
                                       c(" " = "", "\\(" = "", "\\)" = "")))
```
. . .

```{r}
kable(survey_med[1:3, "orientation"], html_font = "Computer Modern", table.attr = "style='width:50%;'")
```

## Exercice 4.1.1 - Correction Q3

**Question 3** : A partir du fichier global_reef_fish_biomass.csv chargé avec `read_delim()`, enchaîner le pipe pour obtenir un data.frame résumant le nombre d'observations dans chacune des classes, pour le site n°2000951 seulement.

. . .

```{r results='hide', eval = FALSE}
global_reef_fish_biomass <- read_delim("./data/global_reef_fish_abundance.csv")

global_reef_fish_biomass %>%
  filter(survey_id == "2000951") %>%
  group_by(class) %>%
  summarise(n_class = n())
```

. . .

```{r echo=FALSE}
load("global_reef_fish_biomass_2000951.RData")
kable(global_reef_fish_biomass_2000951, html_font = "Computer Modern", table.attr = "style='width:50%;'")
```

## Exercice 4.1.1 - Correction Q4 {auto-animate="true"}

**Question 4** : Résolvez le problème de façon à obtenir un tibble de dimension 2x2.

. . .

```{r results='hide', eval = FALSE}
global_reef_fish_biomass %>%
  filter(survey_id == "2000951") %>%
  mutate(class = str_trim(class)) %>%
  group_by(class) %>%
  summarise(n_class = n())
```

. . .

```{r echo=FALSE}
load("global_reef_fish_biomass_2000951OK.RData")
kable(global_reef_fish_biomass_2000951OK, html_font = "Computer Modern", table.attr = "style='width:50%;'")
```

## Les expressions régulières {.smaller}

### Outil très très puissant !

::: columns
::: {.column width="60%"}
-   Il faut savoir que cela existe, mais demande un peu de patience et d'entrainement pour être utilisé
-   Regardez le [deuxième volet](https://github.com/rstudio/cheatsheets/blob/main/strings.pdf){target="_blank"} du cheatsheet de stringr
-   Permet de "selectionner" de manière "dynamique" des patterns dans vos données
-   Le plus difficile est de formuler de la meilleure façon ce que vous voulez
    -   Il y a souvent plusieurs façons d'arriver à ce que vous voulez
    -   Parfois le plus simple est de reformuler ce que vous voulez faire, ou de le faire de manière séquentielle
:::

::: {.column width="40%"}
![](images/regular_expressions.png)
:::
:::

## Exemple concret

```{r echo=TRUE, eval=FALSE}
load(file = "./data/exemple_regular_expressions.RData")

tac_final_modif_level1 <- tac_final %>%
  mutate(adapted_quota = as.numeric(x = adapted_quota_ori)) %>%
  relocate(adapted_quota,
           .after = adapted_quota_ori)

tac_final_modif_level1_check <- filter(.data = tac_final_modif_level1,
                                       is.na(x = adapted_quota)) %>%
  dplyr::select(adapted_quota_ori,
                adapted_quota)

tac_final_modif_level2 <- tac_final %>%
  rowwise() %>%
  mutate(adapted_quota = case_when(
    str_detect(string = adapted_quota_ori,
               pattern = "^[:digit:]+[:punct:][:digit:]+$") ~ str_replace(string = adapted_quota_ori,
                                                                          pattern = "[:punct:]", 
                                                                          replacement = "."),
    TRUE ~ adapted_quota_ori)) %>%
  relocate(adapted_quota,
           .after = adapted_quota_ori) %>%
  mutate(adapted_quota = as.numeric(x = adapted_quota))
```

# 4.2 : Manipuler des dates avec lubridate

## Rends la manipulation des dates et du temps presque agréable sous R

-   Analyse semi-automatique des dates et des heures

-   Les fonctions vont essayer de trouver le séparateur et le format

-   Possibilité de rajouter l'indicateur de fuseau horaire via l'argument tz

```{r echo=TRUE, eval=FALSE}
library(lubridate)
# Identifie l'ordre de l'année (y), le mois (m), le jour (d), l'heure (h), la minute (m) et la second (s) d'un élement fournis à R
ymd()
mdy()
dmy()
ymd_hms()
# Beaucoup de possibilités, jeter un coup d'oeil sur le cheatsheet
```

## Manipulation des élements date-temps

### Modification et extration

```{r echo=TRUE, eval=FALSE}
test_date_time <- ymd_hms("2022-12-05 12:00:00", tz = "CET")
# pour une extraction des informations
second()
hour()
day()
wday()
month()
...
# pour modifier les informations, utiliser les fonctions précédentes avec une assignation (<-)
```

## Tour d'horizon

-   Les fuseaux horaires, un cauchemar par le passé, maintenant ça va mieux

    -   Deux fonctions clés

```{r echo=TRUE, eval=FALSE}
# Pour exprimer un élément dans un autre fuseau horaire
with_tz()
# Pour forcer le changement d'un fuseau horaire mais en conservant la même heure
force_tz()
```

<br/>

-   3 classes pour calculer des intervalles de temps

    -   Periode, durée et intervalle

    -   Le plus "dur" est de définir votre date-temps, après c'est une syntaxe mathématique

## Bonus

-   Les fonctions sont vectorisables !

-   Sur certains jeux de données, les dates-temps sont stockées en nombre de secondes depuis 1970-01-01 00:00:00 UTC. Utiliser cette fonction dans ce cas-là :

```{r echo=TRUE, eval=FALSE}
as_datetime()
```

-   Possibilité de faire des arrondis

```{r echo=TRUE, eval=FALSE}
# arrondi inférieur sur "l'unité" la plus proche
floor_date()
# arrondi inférieur sur "l'unité" la plus proche
round_date()
# arrondie supérieur sur "l'unité" la plus proche
ceiling_date()
```

# Partie 5 : Visualisation des données avec `ggplot2`

![](images/ggplot2_logo.png)

## Ggplot c'est comme la chirurgie *`aes`*thétique :

::: incremental
::: columns
1)  Les jeunes s'y mettent très tôt !

2)  Les moins jeunes sont réticents puis CERTAINS finissent par s'y mettre ![](images/nancy_pelosi.jpg){.absolute top="250" left="300" width="20%"}

3)  C'est un enchainement plus ou moins long d'opérations.

    ![](images/bogdanoff1.jpg){.absolute top="500" left="100" width="21%"} ![](images/bogdanoff1.5.jpg){.absolute top="500" left="300" width="25%"} ![](images/bogdanoff2.jpg){.absolute top="500" left="700" width="25%"}
:::
:::

## Petit aperçu des possibilités :

<center>

[Le site **From Data To Viz**, une pépite](https://r-graph-gallery.com/){preview-link="true"}

![](images/R_graph_gallery.PNG){.absolute top="150" left="200" width="65%"}

## Ggplot, une succession de couches

::: incremental
::: columns
::: column
1.  La Structure

    ```{r echo=FALSE, out.width="85%"}
    data <- iris
    p1 <- ggplot(data, mapping = aes(x = Sepal.Length, y = Sepal.Width)) +
      theme(axis.text  = element_text(size = 25),
            axis.title = element_text(size = 25))
    p1
    ```
:::

::: column
2.  Le Type de représentation

    ```{r echo=FALSE, out.width="85%"}
    p2 <- p1 + geom_point(size = 5)
    p2
    ```
:::
:::

::: columns
::: column
3.  Les Couleurs

    ```{r echo=FALSE, out.width="85%"}
    p3 <- p1 + geom_point(mapping = aes(color = Petal.Width), size = 5) + scale_color_viridis_c()
    p3
    ```
:::

::: column
4.  Le Lifting final

    ```{r echo=FALSE, out.width="85%"}
    p4 <- p3 + theme_bw() +
      theme(axis.text = element_text(size = 25),
                     axis.title = element_text(size = 25))
    p4
    ```
:::
:::
:::

## La structure des données

Pour la démonstration nous allons utiliser le jeu de données `crabs` de la librairie `MASS`.

```{r results='hide'}
library(MASS)
data_crabs <- crabs %>% dplyr::select(sp, sex, CL, CW)

data_crabs %>%
  head(3) %>%
  kbl(digits = 4, caption = "Crabs data") %>%
  kable_classic(html_font = "Computer Modern", full_width = F)
```

. . .

```{r echo=FALSE}
data_crabs %>%
  head(3) %>%
  kbl(digits = 4, caption = "Crabs data") %>%
  kable_classic(html_font = "Computer Modern", full_width = F)
```

## Ggplot pas à pas : La Structure

::: incremental
<div>

Pour la structure de la figure, la fonction à toujours utiliser est `ggplot()` . Les arguments principaux sont :

::: incremental
-   `data = nom.du.dataframe`

-   `mapping = aes(x = variable.x, y = variable.y)`

    ::: incremental
    -   Ici le `aes` signifie **aesthetic**

    -   On verra que d'autres options sont disponibles dans `aes` comme la taille (`size`), la couleur (`color`), la forme (`shape`) ...
    :::
:::

</div>
:::

## Ggplot pas à pas : La Structure

::: nonincremental
<div>

Pour la structure de la figure, la fonction à toujours utiliser est `ggplot()` . Les arguments principaux sont :

<div>

-   `data = nom.du.dataframe`

-   `mapping = aes(x = variable.x, y = variable.y)`

</div>

</div>
:::

```{r warnings=FALSE}
couche.1 <- ggplot(data    = data_crabs,
                   mapping = aes(x = CL, y = CW))
```

. . .

```{r echo=FALSE, fig.align='center', out.width="50%"}
couche.1
```

## Ggplot pas à pas : Choix du plot

::: incremental
::: incremental
Plusieurs représentations existent selon le type de variables que l'on a :
:::

::: columns
::: column
1.  **Une variable continue**

    ::: incremental
    -   `geom_histogram()`

    -   `geom_density()`
    :::
:::

::: column
2.  **Deux variables continues**

    ::: incremental
    -   `geom_point()`
    -   `geom_line()`
    -   `geom_area()`
    :::
:::
:::
:::

::: incremental
::: columns
::: column
3.  **Une discrète & une continue**

    ::: incremental
    -   `geom_boxplot()`
    -   `geom_violin()`
    -   `geom_col()`
    :::
:::

::: column
4.  **Données spatiales**

    ::: incremental
    -   `geom_polygon()`

    -   `geom_sf()`
    :::
:::
:::
:::

## Ggplot pas à pas : Choix du plot

::: incremental
L'exemple ici va mener à la réalisation d'un **nuage de points**. Mais `ggplot2` fonctionne de la même façon pour construire un **diagramme en barres**, **une boite à moustache** ou autres.

::: incremental
::: columns
::: {.column width="50%"}
-   `aes()` dans `ggplot()`

    ```{r warnings=FALSE}
    couche.2 <- ggplot(data    = data_crabs,
                       mapping = aes(x = CL, 
                                     y = CW)) +
      geom_point()
    ```
:::

::: {.column width="50%"}
-   `aes()` dans `geom_point()`

    ```{r warnings=FALSE}
    # Autre solution
    couche.2.2 <- ggplot() +
      geom_point(data    = data_crabs,
                 mapping = aes(x = CL, y = CW))
    ```
:::
:::
:::
:::

. . .

```{r echo = FALSE, fig.align='center', out.width="40%"}
couche.2
```

## Ggplot pas à pas : Modèle linéaire {auto-animate="true"}

Traçons un modèle linéaire et ajoutons la formule et le R² correspondant

. . .

```{r echo = TRUE, fig.align='center'}
couche.3 <- couche.2 +
  geom_smooth(color = "red", method = "lm") # le modèle linéaire 
```

. . .

```{r echo=FALSE, fig.align='center', out.width="70%"}
couche.3
```

## Ggplot pas à pas : Modèle linéaire {auto-animate="true"}

Traçons un modéle linéaire et ajoutons la formule et le R² correspondant

```{r echo = TRUE, fig.align='center', out.width="60%"}
couche.3 <- couche.2 +
  geom_smooth(color = "red", method = "lm") + # le modèle linéaire 
  stat_regline_equation(label.y = 52, aes(label = ..eq.label..)) # la formule
couche.3
```

## Ggplot pas à pas : Modèle linéaire {auto-animate="true"}

Traçons un modèle linéaire et ajoutons la formule et le R² correspondant

```{r echo = TRUE, fig.align='center', out.width="50%"}
couche.3 <- couche.2 +
  geom_smooth(color = "red", method = "lm") + # le modèle linéaire 
  stat_regline_equation(label.y = 52, aes(label = ..eq.label..)) + # la formule
  stat_regline_equation(label.y = 48, aes(label = ..adj.rr.label..)) # R²
couche.3
```

## Exercice 5.1 {auto-animate="true"}

Quel est le pays dans lequel on retrouve le plus de biomasse par transect (valeur médiane) ? Formatter le jeu de données issues de l'exercice 3.6 et représenter visuellement les données sous forme de boites à moustache, **seulement pour les données prélevées en 2011**.

```{r}
# Etape 1
```

## Exercice 5.1 : Correction {auto-animate="true"}

Quel est le pays dans lequel on retrouve le plus de biomasse par transect (valeur médiane) ? Formatter le jeu de données issues de l'exercice 3.6 et représenter visuellement les données sous forme de boites à moustache, **seulement pour les données prélevées en 2011**.

```{r warning=FALSE}
# Etape 1 : Formatter les données
data_biomass_country <- biomass_survey_abundance_exercice3_6 %>%
  st_drop_geometry() %>%
  filter(str_detect(string = survey_date, pattern = "2011")) %>%
  group_by(country, survey_id) %>%
  summarise(biomass = sum(biomass)) 
```

## Exercice 5.1 : Correction {auto-animate="true"}

Quel est le pays dans lequel on retrouve le plus de biomasse par transect (valeur médiane). Formatter le jeu de données issues de l'exercice 3.6 et représenter visuellement les données sous forme de boites à moustache, **seulement pour les données prélevées en 2011**.

```{r fig.align="center", out.width="50", warning=FALSE}
# Etape 2 : Realiser les boites à moustache
ggplot(data = data_biomass_country) +
  geom_boxplot(aes(x = country, y = biomass)) +
  theme_bw() 
```

## Exercice 5.2 {auto-animate="true"}

Ce ggplot n'est cependant pas entièrement satisfaisant ... <br> Nous avons du mal à savoir visuellement quelle est la 2nd ou la 3ème nation avec le plus de biomasse.

. . .

Une solution est d'utiliser la fonction `reorder()` pour ordonner l'axe des x.

Utiliser cette fonction pour ordonner l'axe des x de façon décroissante selon la valeur **médiane**. Nommer le plot **boxplot_biomass_country**. <br> N'hésitez pas à regarder l'aide `?reorder` ou à chercher sur internet.

```{r}
# Utilisation de reorder
```

## Exercice 5.2 : Correction {auto-animate="true"}

```{r fig.align="center"}
# Reorder en fonction de la valeur médiane 
boxplot_biomass_country <- ggplot(data = data_biomass_country) +
  geom_boxplot(aes(x = reorder(country, -biomass, FUN = median), y = biomass))

boxplot_biomass_country
```

## Ggplot pas à pas : La couleur

Donnons une couleur par sexe. Comme c'est lié à l'esthétisme de la figure, il faut retourner à l'argument `color` dans la fonction `aes()`.

. . .

```{r warnings=FALSE}
couche.4 <- ggplot() +
  geom_point(data    = data_crabs,
             mapping = aes(x     = CL, 
                           y     = CW, 
                           color = sex))
```

. . .

```{r echo=FALSE, fig.align='center', out.width="70%"}
couche.4
```

## Ggplot pas à pas : Couleurs & légende

Pour cela, on peut utiliser la fonction `scale_color_manual()` et les arguments `name` et `values`.

. . .

```{r warnings=FALSE}
couche.5 <- couche.4 +
  scale_color_manual(name   = "Sex :",
                     values = c("M" = "darkblue", 
                                "F" = "darkgreen"))

```

. . .

```{r echo=FALSE, fig.align='center', out.width="80%"}
couche.5
```

. . .

<center>Une autre façon de faire est d'utiliser la fonction `labs` qui permet de changer les diverses légendes (axes x et y + légende de couleur)</center>

## Ggplot pas à pas : Légende v.2

```{r warnings=FALSE, fig.align='center'}
couche.6 <- couche.5 +
  labs(x     = "Carapace Length (mm)",
       y     = "Carapace Width (mm)",
       color = "Sex :")
```

. . .

```{r echo=FALSE, fig.align='center'}
couche.6
```

## Exercice 5.3 {auto-animate="true"}

Renommer proprement les axes de boxplot_biomass_country.

```{r}
# Solution
```

## Exercice 5.3 - Corrigé {auto-animate="true"}

Renommer proprement les axes de boxplot_biomass_country.

```{r}
# Solution
boxplot_biomass_country_v2 <- boxplot_biomass_country +
  labs(x = "Country", y = "Biomass (g)")
```

```{r echo = FALSE, fig.align="center", out.width="70%"}
boxplot_biomass_country_v2
```

## Ggplot pas à pas : le FACET

La fonction `facet_grid()` permet de générer X plots pour chaque valeur d'une variable qualitative (i.e. le sexe).

. . .

```{r}
couche.7 <- couche.6 + facet_grid(~sp)
```

. . .

```{r echo=FALSE, fig.align='center', out.width="70%"}
couche.7
```

## Ggplot pas à pas : l'arrière plan

<br> On utilise une des fonctions `theme_*`.

<br>

```{r warnings=FALSE, fig.align='center'}
#| fig-height: 8
#| layout: "[30, 30, 30]"
couche.7 + theme_bw()
couche.7 + theme_classic()
couche.7 + theme_dark()
```

. . .

<center>Un tas de `theme_*` existent pour obtenir différentes formats d'arrière plan (voir [ici](http://www.sthda.com/english/wiki/ggplot2-themes-and-background-colors-the-3-elements)). A vous de choisir votre préféré.</center>

## Ggplot pas à pas : le lifting final

La fonction `theme()` permet de lifter BEAUCOUP de choses (`?theme`). <br> Elle doit toujours apparaître en dernier de façon à ne pas être écrasée par une autre couche.

. . .

```{r}
couche.8 <- couche.7 +
  theme_bw() +
  theme(axis.text       = element_text(size = 11),
        axis.title      = element_text(size = 13),
        legend.position = "right",
        legend.text     = element_text(size = 13),
        legend.title    = element_text(size = 15))
```

. . .

```{r echo=FALSE, fig.align='center', out.width="50%"}
couche.8
```

## Enregistrer ses figures

<br>

Pour enregistrer votre ggplot, vous pouvez utiliser la fonction `ggsave()` :

<br>

::: incremental
-   `plot` : le nom du ggplot à enregistrer.
-   `filename` : le_chemin_daccess/le_nom_denregistrement.EXTENSION
-   `width` & `height` : la largeur et hauteur d'enregistrement.
:::

. . .

<center>

D'autre arguments existent, voir avec `?ggsave`.

## Exercice 5.4 {auto-animate="true"}

Dans la fonction `element_text()`, un argument permet de tourner les légendes des axes pour que les pays soient plus lisibles. Trouver cet argument et appliquer une rotation de 45° à la légende de l'axe x. Choisir votre arrière plan préféré.

```{r}
# Solution
```

## Exercice 5.4 - Corrigé {auto-animate="true"}

Dans la fonction `element_text()`, un argument permet de tourner les légendes des axes pour que les pays soient plus lisibles. Trouver cet argument et appliquer une rotation de 45° à la légende de l'axe x. Choissir votre arrière plan préféré.

```{r}
# Solution
boxplot_biomass_country_v3 <- boxplot_biomass_country_v2 +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

. . .

```{r echo=FALSE, fig.align="center", out.width="60%"}
boxplot_biomass_country_v3
```

## Exercice 5.5 {auto-animate="true"}

Enregistrer la **boxplot_biomass_country_v3** au format **.png**, avec une largeur et hauteur appropriées pour lire correctement le plot.

```{r}
# Solution
```

## Exercice 5.5 corrigé {auto-animate="true"}

Enregistrer la **boxplot_biomass_country_v3** au format **.png**, avec une largeur et hauteur appropriées pour lire correctement le plot.

```{r eval = FALSE}
# Solution
ggsave(filename = "figures/boxplot_biomass_vs_country.png", 
       plot     = boxplot_biomass_country_v3,
       width    = 8,
       height   = 5)
```

## Une petite subtilité concernant les couleurs

### Exercice 5.6 {auto-animate="true"}

::: incremental
1.  A partir de data_biomass_country, selectionnez les pays **Spain**, **United States**, **Canada**, **Costa Rica** et **Mexico**.

2.  Créer une nouvelle colonne qui précise leur continent.

3.  Reconstruire un boxplot en **remplissant** chaque boite d'une couleur pour chaque continent.
:::

. . .

```{r}
# Solution
```

## Exercice 5.6 corrigé {auto-animate="true"}

1.  A partir de data_biomass_country, selectionnez les pays **Spain**, **United States**, **Canada**, **Costa Rica** et **Mexique**.

2.  Créer une nouvelle colonne qui précise leur continent.

3.  Reconstruire un boxplot en **remplissant** chaque boite d'une couleur pour chaque continent.

```{r}
# Solution questions 1 & 2
data_biomass_5country <- data_biomass_country %>%
  filter(country %in% c("Spain", "United States", "Italy", "Costa Rica", "Panama")) %>%
  mutate(Continent = case_when((country == "Spain"| country == "Italy") ~ "Europe",
                                country == "United States" ~ "North America",
                                TRUE ~ "South America"))

# Solution pour le plot
```

## Exercice 5.6 corrigé {auto-animate="true"}

1.  A partir de data_biomass_country, selectionnez les pays <br> **Spain**, **United States**, **Canada**, **Costa Rica** et **Mexique**.

2.  Créer une nouvelle colonne qui précise leur continent.

3.  Reconstruire un boxplot en **remplissant** chaque boite d'une couleur propre à son continent.

```{r}
# Solution questions 1 & 2
data_biomass_5country <- data_biomass_country %>%
  filter(country %in% c("Spain", "United States", "Italy", "Costa Rica", "Panama")) %>%
  mutate(Continent = case_when((country == "Spain"| country == "Italy") ~ "Europe",
                                country == "United States" ~ "North America",
                                TRUE ~ "South America"))

# Solution pour le plot
plot <- ggplot() +
  geom_boxplot(data    = data_biomass_5country,
               mapping = aes(x = reorder(country, -biomass, FUN = median), 
                             y = biomass, 
                             color = Continent)) +
  labs(x = "Country", y = "Biomass (g)") + 
  theme_bw()
```

## Exercice 5.6 corrigé {auto-animate="true"}

```{r echo = FALSE, fig.align="center", out.width="50%"}
plot
```

::: incremental
Ggplot fait la différence entre :

-   la couleur des contours --\> `color = …`

-   la couleur de remplissage --\> `fill = …`
:::

. . .

Pour choisir ses couleurs de contour *vs.* de remplissage, on utilise les fonctions\
`scale_color_manual()` *vs.* `scale_fill_manual()`.

A vous de jouer en attribuant la couleur **skyblue** à l'Europe, **aquamarine** à l'Am. du Sud et **moccasin** à l'Am. du Nord.

## Exercice 5.6 corrigé {auto-animate="true"}

A vous de jouer en attribuant la couleur **skyblue** à l'Europe, **aquamarine** à l'Am. du Sud et **moccasin** à l'Am. du Nord.

```{r }
ggplot() +
  geom_boxplot(data    = data_biomass_5country,
               mapping = aes(x = reorder(country, -biomass, FUN = median), 
                             y = biomass, 
                             fill = Continent)) +
  scale_fill_manual(values = c("Europe" = "skyblue", 
                               "South America" = "aquamarine", 
                               "North America" = "moccasin")) +
  labs(x = "Country", y = "Biomass (g)") + 
  theme_bw()
```

## Une autre subtilité concernant les couleurs

Construisons un nuage de points entre la biomasse et la profondeur

. . .

```{r echo = FALSE}
data_biomass_depth <- biomass_survey_abundance_exercice3_6 %>%
  st_drop_geometry() %>%
  filter(str_detect(string = survey_date, pattern = "2011")) %>%
  group_by(country, survey_id) %>%
  summarise(biomass = sum(biomass),
            depth   = unique(depth)) 

```

```{r results="hide"}
plot <- ggplot() +
  geom_point(data    = data_biomass_depth,
             mapping = aes(x     = depth, 
                           y     = biomass,
                           color = biomass)) +
  scale_color_manual(values = "blue")
```

. . .

```{r echo = FALSE, error=TRUE, out.width="0%"}
plot
```

. . .

<center>

On ne peut pas donner une seule couleur à une variable continue !

## Couleurs & variables continues

Il existe 4 fonctions principales qui permettent de construire des palettes de couleurs continues :

::: incremental
-   `scale_fill_continuous` : avec une palette par defaut (nuances de bleus)

-   `scale_fill_viridis_c` : Colorblind friendly.

-   `scale_fill_distiller` : utilise les [BrewerPalettes](https://colorbrewer2.org/#type=sequential&scheme=BuGn&n=3) (voir [ici](https://r-graph-gallery.com/38-rcolorbrewers-palettes.html) pour plus d'infos).\
    Pour voir les palettes =\> `RColorBrewer::display.brewer.all()`

-   `scale_fill_gradient` : permet de créer ses propres gradients de couleurs. Des variantes existent selon le nombre de couleurs à définir. Il s'agit de `scale_fill_gradient2()` et `scale_fill_gradientn()`.
:::

## Couleurs & variables continues

<center>Testons les une par une à partir de la figure suivante</center>

```{r}
plot <- ggplot(faithfuld, aes(waiting, eruptions, fill = density)) +
  geom_raster() +
  scale_x_continuous(NULL, expand = c(0, 0)) + 
  scale_y_continuous(NULL, expand = c(0, 0)) + 
  theme(legend.position = "none")
```

## Couleurs & variables continues

### `scale_color_continuous`

La plus simple, mais pas beaucoup d'options. C'est aussi la palette de couleur par défaut.

. . .

```{r fig.align='center'}
#| fig-height: 8
#| layout: "[50, 50]"
plot
plot + scale_fill_continuous()
```

## Couleurs & variables continues

### `scale_color_viridis_c`

De belles palettes dont les nuances sont captées par les personnes daltoniennes.

. . .

::: incremental
```{r}
#| fig-height: 8
#| layout: "[30, 30, 30]"
plot + scale_fill_viridis_c(option = "viridis")
plot + scale_fill_viridis_c(option = "inferno")
plot + scale_fill_viridis_c(option = "turbo")
```
:::

## Couleurs & variables continues

### `scale_fill_distiller()`

Permet d'utiliser les palettes de couleurs issues de [BrewerPalettes](https://colorbrewer2.org/#type=sequential&scheme=BuGn&n=3).

. . .

```{r fig.align='center'}
RColorBrewer::display.brewer.all()
```

## Couleurs & variables continues

### `scale_fill_distiller()`

. . .

Permet d'utiliser les palettes de couleurs issues de [BrewerPalettes](https://colorbrewer2.org/#type=sequential&scheme=BuGn&n=3).

```{r}
#| fig-height: 8
#| layout: "[30, 30, 30]"
plot + scale_fill_distiller(palette = "Reds")
plot + scale_fill_distiller(palette = "YlGn")
plot + scale_fill_distiller(palette = "Spectral")
```

## Couleurs & variables continues

### `scale_fill_distiller()`

Petite info utile, toutes les palettes peuvent passer le test ***ColorBlind Friendly*** :

. . .

```{r fig.align='center', out.width="80%"}
color_pal <- RColorBrewer::brewer.pal(10, name="Spectral")
colorBlindness::displayAllColors(color_pal)
```

## Couleurs & variables continues {.smaller}

### `scale_fill_gradient()`

Permet de créer ses propres palettes de couleurs, à partir de 2, 3 ou n couleurs :

::: incremental
-   `scale_fill_gradient()` avec les arguments `low` et `high`.

-   `scale_fill_gradient2()` avec les arguments `low`, `mid` et `high`.

-   `scale_fill_gradientn()` avec l'argument `colours`.
:::

. . .

```{r}
#| fig-height: 8
#| layout: "[30, 30, 30]"
plot + scale_fill_gradient(low = "darkblue", high = "darkred")
plot + scale_fill_gradient2(low = "darkblue", mid = "white", high = "darkred", midpoint = 0.02)
plot + scale_fill_gradientn(colours = colorspace::diverge_hcl(7))
```

## Couleurs & variable groupée en classes

Il existe 3 fonctions principales qui permettent de construire ce type de palettes de couleurs :

::: incremental
-   `scale_fill_binned` : avec une palette par défaut (nuances de bleus)

-   `scale_fill_fermenter` : utilise les [BrewerPalettes](https://colorbrewer2.org/#type=sequential&scheme=BuGn&n=3) (voir [ici](https://r-graph-gallery.com/38-rcolorbrewers-palettes.html) pour plus d'infos).\
    Pour voir les palettes =\> `RColorBrewer::display.brewer.all()`

-   `scale_fill_steps` : permet de créer sa propre palette avec un nombre de classes précis. Des variantes existent selon le nombre de couleurs à définir. Il s'agit de `scale_fill_steps2()` et `scale_fill_stepsn()`.
:::

## Couleurs & variable groupée en classes

### `scale_fill_binned()`

Les couleurs sont par défaut une nuance de bleus. Certaines précisions peuvent cependant être apportées.

. . .

```{r}
#| fig-height: 8
#| layout: "[30, 30, 30]"
plot + scale_fill_binned(n.breaks = 4)
plot + scale_fill_binned(n.breaks = 7)
plot + scale_fill_binned(breaks = quantile(faithfuld$density, probs = (seq(0,1,0.3))))
```

## Couleurs & variable groupée en classes

### `scale_fill_fermenter()`

Fonction analogue à `scale_fill_distiller()` et `scale_fill_brewer()`.

. . .

```{r}
#| fig-height: 8
#| layout: "[30, 30, 30]"
plot + scale_fill_fermenter(n.breaks = 8, palette = "BuGn")
plot + scale_fill_fermenter(n.breaks = 8, palette = "BuGn", direction = 1)
plot + scale_fill_fermenter(n.breaks = 8, palette = "RdBu")
```

## Couleurs & variable groupée en classes

### `scale_fill_steps()`

Fonction analogue à `scale_fill_gradient()`.

::: incremental
-   `scale_fill_steps()` avec les arguments `low` et `high`.

-   `scale_fill_steps2()` avec les arguments `low`, `mid` et `high`.

-   `scale_fill_stepsn()` avec l'argument `colours`.
:::

. . .

```{r}
#| fig-height: 8
#| layout: "[30, 30, 30]"
plot + scale_fill_steps(low = "darkblue", high = "darkred", n.breaks = 8)
plot + scale_fill_steps2(low = "darkblue", mid = "white", high = "darkred", midpoint = 0.02, n.breaks = 8)
plot + scale_fill_stepsn(colors = magma(9), n.breaks = 9)
```

## Couleurs & variables discrètes

Les principales fonctions utilisées permettant de construire des palettes de couleurs continues :

::: incremental
-   `scale_fill_discrete` : Couleurs par défaut

-   `scale_fill_manual` : choix de la couleur parmi toutes les couleurs existantes.

-   `scale_fill_brewer` : utilise les [BrewerPalettes](https://colorbrewer2.org/#type=sequential&scheme=BuGn&n=3) (voir [ici](https://r-graph-gallery.com/38-rcolorbrewers-palettes.html) pour plus d'infos). Equivalent de `scale_fill_distiller` pour les variables discrètes.
:::

## Couleurs & variables discrètes

::: incremental
```{r}
plot <- ggplot() +
  geom_violin(data    = data_crabs,
              mapping = aes(x = sex, y = CL, fill = sex), 
              alpha   = 0.7) +
  facet_wrap(~sp) +
  theme_bw()
```
:::

. . .

::: incremental
```{r}
#| fig-height: 8
#| layout: "[30, 30, 30]"
plot + scale_fill_discrete()
plot + scale_fill_manual(values = c("M" = "darkblue", "F" = "darkgreen"))
plot + scale_fill_brewer(palette = "Set2")
```
:::

## Ressources utilisées

https://ggplot2-book.org/scale-colour.html#colour-discrete

https://stackoverflow.com/questions/70942728/understanding-color-scales-in-ggplot2

https://colorbrewer2.org/#type=sequential&scheme=BuGn&n=3

## Diagrammes en barres & barres d'erreurs

Pour ajouter les barres d'erreurs, on utilise la fonction `geom_errorbar()`.

. . .

L'utilisation de cette fonction nécessite le calcul préalable de l'écart-type.

. . .

```{r}
# Formattage des données
crabs_mean <- data_crabs %>%
  group_by(sp) %>%
  summarise(CL_mean = mean(CL),
            CL_sd   = sd(CL)) 

```

. . .

```{r fig.align="center", out.width="30%"}
# Réalisation du diagramme en barres
ggplot(crabs_mean) +
  geom_col(aes(x = sp, y = CL_mean)) +
  geom_errorbar(aes(x = sp, ymin = CL_mean-CL_sd, ymax = CL_mean+CL_sd)) +
  theme_bw()
```

## Exercice 5.7 {auto-animate="true"}

A partir des données data_biomass_5country, construire un diagramme en barres  de la biomasse moyenne par transect. Classer l'axe des x dans l'ordre **croissant**. Trouvez la façon de rendre les barres moins larges et de changer leur couleur.

## Exercice 5.7 - Corrigé {auto-animate="true"}

A partir des données data_biomass_5country, construire un diagramme en barres  de la biomasse moyenne par transect. Classer l'axe des x dans l'ordre **croissant**. Trouvez la façon de rendre les barres moins larges et de changer leur couleur.

```{r fig.align='center', out.width="40%"}
# Formattage
country_mean <- data_biomass_5country %>%
  group_by(country) %>%
  summarise(biom_mean = mean(biomass),
            biom_sd   = sd(biomass)) 
```

## Exercice 5.7 - Corrigé {auto-animate="true"}

A partir des données data_biomass_5country, construire un diagramme en barres  de la biomasse moyenne par transect. Classer l'axe des x dans l'ordre **croissant**. Trouvez la façon de rendre les barres moins larges et de changer leur couleur.

```{r fig.align='center', out.width="70%"}
# Figure 
ggplot(country_mean) +
  geom_col(aes(x = reorder(country, biom_mean), y = biom_mean)) +
  geom_errorbar(aes(x = country, ymin = biom_mean-biom_sd, ymax = biom_mean+biom_sd),
                    width = 0.2, colour = "red") +
  labs(x = "Country", y = "Biomass (g)") + 
  theme_bw()
```

## Utiliser ggplot pour détecter des erreurs dans les données

<center>

```{r echo = TRUE, warning = FALSE}
# fish_data <- read_csv("data/Global_reef_fish_abundance_and_biomass.csv")
# fish_data <- read_csv("data/Global_reef_fish_biomass.csv")

# survey <- read_delim("data/Survey_metadata.csv", 
#      delim = ";", escape_double = FALSE, trim_ws = TRUE, 
#      skip = 70)

# Selection des données pour le site n°2000951
# site1 <- fish_data %>%
#   filter(survey_id == 2000951) %>%
#   select(survey_id, class, order, family, species_name, total, biomass)
# 
# site1 %>%
#   head(5) %>% 
#   kbl(digits = 4, caption = "Data to check") %>% 
#   kable_classic(html_font = "Computer Modern", full_width = F)  

```

</center>

Comment détecter les outliers ?

```{r echo = TRUE, warning = FALSE}
# ggplot(data = site1, mapping = aes(x = order, y = biomass)) +
#   geom_boxplot() +
#   theme_bw()
```

### Séparer les Elasmobranches des Actinoptérygiens

<center>

```{r echo=TRUE, warning=FALSE}
# ggplot(data = site1, mapping = aes(x = order, y = biomass)) +
#   geom_boxplot() +
#   facet_grid(.~class, scales = "free", space = "free") +
#   theme_bw() +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Interrogation au niveau des Perciformes ...

</center>

### Qu'est-ce qu'il se passe avec les Perciformes ?

<center>

```{r echo=TRUE, warning=FALSE}
# site1 %>%
#   filter(order == "Perciformes") %>%
#   ggplot(., mapping = aes(x = family, y = biomass)) +
#   geom_boxplot() +
#   theme_bw() +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
  

```

</center>

## La cartographie avec ggplot2

Toutes les fonctions et la syntaxe montrées précédemment fonctionnent ici

```{r echo=TRUE, eval=TRUE}
# Pour cette partie nous utiliserons un shape file des pays de la librarie rnaturalearth
library(rnaturalearth)
# install.packages("rnaturalearthdata")
world_boundaries <- ne_countries(returnclass = "sf", scale ="medium") 
# dim(world_boundaries)
# head(world_boundaries)
```

-   Plotter des données spatialisées

```{r echo=TRUE, eval=FALSE}
# Pour les objets spatialisés de type vectoriel au format sf
geom_sf()
# Permet d'extraire les coordonnées d'un objet sf
stat_sf_coordinates()
# Pour les objets spatialisés au format raster
geom_raster()
# Attention geom_raster ne reçoit pas un objet directement au format raster 
# mais un data frame
```

## 

-   Applications

    -   Visualiser la carte

```{r}
map1 <- ggplot(data = world_boundaries) + 
  geom_sf(fill="transparent") +
  theme_bw()
map1
```

## 

-   Applications

    -   Afficher sur chaque pays un rond dont la taille est proportionnelle à la population

```{r, eval=FALSE}
map2 <- map_1 + 
  stat_sf_coordinates(aes(size=pop_est, fill=gdp_md_est),color = "black",shape=21, data = world_boundaries) +
  labs(fill="GDP") +
scale_size_binned(breaks = quantile(world_boundaries$pop_est, probs = seq(0,1,0.1),na.rm=TRUE)) +
  theme_bw()
map2 
```

## 

-   Applications

    -   Créer un raster et le visualiser

::: incremental
```{r, eval=FALSE}
r <- raster(ncols=5, nrows=5)
r1 <- setValues(r, runif(ncell(r)))

rastdf <- as.data.frame(r1,xy=TRUE)
head(rastdf)
```

```{r, eval=FALSE}
map3.1 <- ggplot() +
    geom_raster(data=rastdf, aes(x=x,y=y))
Map3.1
```

```{r, eval=FALSE}
# Ajouter l'argument fill 
map3.2 <- ggplot() +
    geom_raster(data=rastdf, aes(x=x,y=y,fill=layer))
map3.2
```
:::

## 

-   Ajouter des étiquettes et du texte

```{r echo=TRUE, eval=FALSE}
# Afficher du texte
#Interet de l'argument check_overlap
geom_sf_text()
# Afficher des étiquettes
geom_sf_label()
```

##  {.smaller}

-   Applications

    -   Afficher sous format texte le code ISO3 des pays

    ```{r, eval=FALSE}
    map_4.1 <- map1 +
      geom_sf_text(aes(label = adm0_a3),vjust=-0.5,fontface="italic",colour="blue") +
      theme_bw()
    map4.1
    ```

    -   Ajout de l'argument check_overlap. Que se passe t'il?

```{r, eval=FALSE}
map_4.2 <- map1 +
  geom_sf_text(aes(label = adm0_a3),vjust=-0.5,check_overlap=TRUE,fontface="italic",colour="blue") +
  theme_bw()
map4.2
```

    - Afficher sous format étiquette le code ISO3 des pays

```{r, eval=FALSE}
map_5 <- map1 +
  geom_sf_label(aes(label = adm0_a3),vjust=-0.5,colour="blue",fill="cyan") +
  theme_bw()
Map5
```

## 

-   Peaufiner les cartes avec `ggspatial`

```{r echo=TRUE, eval=FALSE}
# Ajout de la barre d'échelle
annotation_scale()
# Ajout de la flèche du nord
annotation_north_arrow()
```

## 

-   Application

    -   Ajouter la barre d'échelle

```{r, eval=FALSE}
# Le filter peut aussi etre fait directement dans le graphe
map6 <- ggplot(data = world_boundaries %>% filter(continent=="South America")) +
  geom_sf() +
 annotation_scale(location = "br", line_width = .5) +
  theme_bw()
map6
```

## 

-   Application

    -   Ajouter la flèche du nord

```{r, eval=FALSE}
map_6 <- map_5 +
  annotation_north_arrow(location = "tl", height = unit(0.7, "cm"), width = unit(0.7, "cm"))
```

## Exercice 5.X {.smaller auto-animate="true"}

-   Construisez une carte des transects en Méditerranée avec une couleur par "site_name" et un shape par "method". Choisissez une palette de couleurs cohérente avec les données et masquez la légende

```{r echo=TRUE, eval=FALSE}
# solution
```

## Exercice 5.X corrigé {.smaller auto-animate="true"}

-   Construisez une carte des transects en Méditerranée avec une couleur par "site_name" et un shape par "method". Choisissez une palette de couleurs cohérente avec les données et masquez la légende

```{r, eval=FALSE}
# solution
med_map1 <- ggplot(data = survey_med) +
  geom_sf(aes(color=site_name, shape=method), show.legend = FALSE) +
  scale_colour_viridis_d() +
  #scale_shape_manual(values = rep(15:17, len = 8)) +
  theme_bw()
med_map1
```

## Exercice 5.X+1 {.smaller auto-animate="true"}

-   Ajoutez au résultat précédent un fond de carte avec les pays en gris clair (grey92)

```{r echo=TRUE, eval=FALSE}
# solution
```

## Exercice 5.X+1 corrigé {.smaller auto-animate="true"}

-   Ajoutez au résultat précédent un fond de carte avec les pays en gris clair (grey92)

```{r echo=TRUE, eval=FALSE}
# solution
med_countries <- world_boundaries %>%
  filter(continent %in%c("Europe","Africa","Asia"))
med_map2 <- med_map1  +
  geom_sf(data=med_country, fill="gray92")
med_map2
```

## Exercice 5.X+2 {.smaller auto-animate="true"}

-   Recentrez la carte autour des pays d'intérêt

```{r echo=TRUE, eval=FALSE}
# solution
```

## Exercice 5.X+2 corrigé {.smaller auto-animate="true"}

-   Recentrez la carte autour des pays d'intérêt

```{r, eval=FALSE}
# solution
med_map2 <- med_map1  +
  geom_sf(data=med_country, fill="gray92") +
xlim(-20,60) +
ylim(4,-10)
med_map2
```

## Exercice 5.X+3 {.smaller auto-animate="true"}

-   Pour chaque pays ajouter un cercle proportionnel au nombre de transects réalisés sur ses côtes

```{r echo=TRUE, eval=FALSE}
# solution
```

## Exercice .X+3 corrigé {.smaller auto-animate="true"}

-   Pour chaque pays ajouter un cercle proportionnel au nombre de transects réalisés sur ses côtes

```{r echo=TRUE, eval=FALSE}
# solution
survey_med_nsample <- survey_med %>%
  group_by(country) %>%
  mutate(n_sample = n()) %>%
  slice(1) %>%
  data.frame() %>%
  select(c(country,n_sample))
country_med_nsample <- left_join(med_country,survey_med_sample,by=c("name"="country"))
```

```{r, eval=FALSE}
med_map3 <- med_map2 +
  stat_sf_coordinates(aes(size=n_sample),color = "white",fill="red",shape=21, data = country_med_nsample)
med_map3
```

## Exercice X+4 {.smaller auto-animate="true"}

-   Ajouter la carte de bathymétrie. Pour la charger utiliser la commande raster::raster("bathy_med.tif) Que remarquez vous ?

```{r echo=TRUE, eval=FALSE}
# solution
```

## Exercice X+4 corrigé {.smaller auto-animate="true"}

-   Ajouter la carte de bathymétrie. Pour la charger utiliser la commande raster::raster("bathy_med.tif) Que remarquez vous ?

```{r echo=TRUE, eval=FALSE}
# solution
bathy_med <- raster::raster("bathy_med.tif)
rasdf <- as.data.frame(bathy_med,xy=TRUE)
```

```{r, eval=FALSE}
# solution
med_map4 <- med_map3 + geom_raster(data=rasdf, aes(x=x,y=y,fill=Gebco2019_500m))
med_map4
```

## Exercice X+4 corrigé {.smaller auto-animate="true"}

-   Ajouter la carte de bathymétrie. Pour la charger utiliser la commande raster::raster("bathy_med.tif) Que remarquez vous ?

```{r echo=TRUE, eval=FALSE}
# solution
bathy_med <- raster::raster("bathy_med.tif)
rasdf <- as.data.frame(bathy_med,xy=TRUE)
```

```{r, eval=FALSE}
# solution
med_map4 <- ggplot(data = survey_med) +
  geom_raster(data=rasdf, aes(x=x,y=y,fill=Gebco2019_500m)) +
  geom_sf(data=med_country, fill="gray92") +
  geom_sf(aes(color=site_name, shape=methods), show.legend = FALSE) +
  scale_colour_viridis_d() +
  scale_shape_manual(values = rep(15:17, len = 8)) +
  theme_bw()
med_map4
```

## Exercice 5.X+5 {.smaller auto-animate="true"}

-   Customisez la carte avec la flêche du Nord, le nom des axes et un titre. Renommez la légende et ajoutez une palette de couleurs distinguant terre et mer pour la bathymétrie

```{r echo=TRUE, eval=FALSE}
# solution
```

## Exercice 5.X+5 corrigé {.smaller auto-animate="true"}

-   Customisez la carte avec la flêche du Nord, le nom des axes et un titre. Renommez la légende et ajoutez une palette de couleurs distinguant terre et mer pour la bathymétrie

```{r echo=TRUE, eval=FALSE}
# solution
med_map5 <- ggplot(data = survey_med) +
  geom_raster(data=rasdf, aes(x=x,y=y,fill=Gebco2019_500m)) +
  geom_sf(data=med_country, fill="gray92") +
  geom_sf(aes(color=site_name, shape=methods), show.legend = FALSE) +
  scale_colour_viridis_d() +
  scale_shape_manual(values = rep(15:17, len = 8)) +
  theme_bw() +
  annotation_north_arrow(location = "tl", height = unit(0.7, "cm"), width = unit(0.7, "cm")) + 
  labs(x="longitude",
       y="latitude",
       title="RLS mediterranean survey",
       fill ="bathymétrie") +
  scale_fill_gradient2(low = "blue", mid = "white", high = "brown")
med_map5
```

## Exercice 5.X+6 {.smaller auto-animate="true"}

-   Sauvegardez votre belle carte :)

```{r echo=TRUE, eval=FALSE}
# solution
```

## Exercice 5.X+6 corrigé {.smaller auto-animate="true"}

-   Sauvegardez votre belle carte :)

```{r echo=TRUE, eval=FALSE}
# solution
ggsave("RLS_med.pdf",plot=med_map5, width = 15, height = 10, units = "cm")
```
